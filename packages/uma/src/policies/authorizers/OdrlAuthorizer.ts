import {Authorizer} from "./Authorizer";
import {ODRL, UconRequest, UCRulesStorage} from "@solidlab/ucp";
import {WEBID} from "../../credentials/Claims";
import {ODRLEvaluator, ODRLEngineMultipleSteps, EyeReasoner} from 'odrl-evaluator'
import {DataFactory, Literal, NamedNode, Quad_Subject, Store, Term, Writer} from "n3";
import quad = DataFactory.quad;
import namedNode = DataFactory.namedNode;
import literal = DataFactory.literal;
import {generate_uuid} from "koreografeye";
import {createVocabulary, DC, RDF} from "@solid/community-server";
import { Logger } from "../../util/logging/Logger";
import {getLoggerFor} from "../../util/logging/LoggerUtils";
import {ClaimSet} from "../../credentials/ClaimSet";
import {Permission} from "../../views/Permission";
import {Requirements} from "../../credentials/Requirements";

export class OdrlAuthorizer implements Authorizer {
    protected readonly logger: Logger = getLoggerFor(this);
    private readonly odrlEvaluator: ODRLEvaluator;

    /**
     * Creates a OdrlAuthorizer enforcing policies using ODRL with the ODRL Evaluator.
     *
     * @param policies - A store containing the ODRL policy rules.
     */
    constructor(
        private readonly policies: UCRulesStorage,
    ) {
        const engine = new ODRLEngineMultipleSteps(new EyeReasoner('/usr/local/bin/eye', ["--quiet", "--nope", "--pass-only-new"]));
        // const engine = new ODRLEngineMultipleSteps();
        this.odrlEvaluator = new ODRLEvaluator(engine);
    }

    public async permissions(claims: ClaimSet, query?: Permission[]): Promise<Permission[]> {
        this.logger.info('Calculating permissions.', {claims, query});
        if (!query) {
            this.logger.warn('The OdrlAuthorizer can only calculate permissions for explicit queries.')
            return [];
        }
        
        const requests: UconRequest[] = [];
        for (const {resource_id, resource_scopes} of query) {

            if (!resource_id) {
                this.logger.warn('The OdrlAuthorizer can only calculate permissions for explicit resources.');
                continue;
            }

            // ODRL can only handle odrl actions
            requests.push({
                subject: typeof claims[WEBID] === 'string' ? claims[WEBID] : 'urn:solidlab:uma:id:anonymous',
                resource: resource_id,
                action: resource_scopes ? transformActionsCssToOdrl(resource_scopes) : ["http://www.w3.org/ns/odrl/2/use"],
                claims
            });
        }
        const permissions: Permission[] = await Promise.all(requests.map(
            async (request) => {
                const scopes_permitted = [];

                // prepare sotw
                const sotw = new Store();

                sotw.add(quad(namedNode('http://example.com/request/currentTime'), namedNode('http://purl.org/dc/terms/issued'), literal(new Date().toISOString(), namedNode("http://www.w3.org/2001/XMLSchema#dateTime"))));

                // prepare policy
                const policyStore = (await this.policies.getStore())


                for (const action of request.action) {
                    // prepare request
                    const req = new Store();
                    const requestNode = generate_uuid();
                    const permissionNode = generate_uuid();
                    req.add(quad(requestNode, RDF.terms.type, ODRL.terms.Request));
                    req.add(quad(requestNode, ODRL.terms.permission, permissionNode));

                    req.add(quad(permissionNode, RDF.terms.type, ODRL.terms.Permission));
                    req.add(quad(permissionNode, ODRL.terms.assignee, namedNode(request.subject)));
                    req.add(quad(permissionNode, ODRL.terms.target, namedNode(request.resource)));
                    req.add(quad(permissionNode, ODRL.terms.action, namedNode(action)));

                    // evaluate policies
                    const reports = await this.odrlEvaluator.evaluate([...policyStore], [...req], [...sotw]);
                    const reportStore = new Store(reports)

                    // TODO: handle multiple reports -> possible to be generated
                    // NOTE: current strategy, add all actions of active reports generated by the request
                    // fetch active and attempted
                    // console.log(new Writer().quadsToString([...req]))

                    const PolicyReportNodes = reportStore.getSubjects(RDF.type, CR.PolicyReport, null);
                    for (const policyReportNode of PolicyReportNodes) {
                        const policyReport = parseComplianceReport(policyReportNode, reportStore)
                        // console.log(new Writer().quadsToString([...policyStore]))
                        // console.log(new Writer().quadsToString([...sotw]))
                        // console.log(new Writer().quadsToString(reports))
                        if (policyReport.ruleReport.activationState === ActivationState.Active &&
                            policyReport.ruleReport.type === RuleReportType.PermissionReport) {
                            scopes_permitted.push(action)
                        }
                    }

                }
                // extract allowed scopes
                return {
                    resource_id: request.resource,
                    resource_scopes: transformActionsOdrlToCss(scopes_permitted)
                }
            }
        ));
        // console.log(permissions)
        return permissions;
    }

    public async credentials(permissions: Permission[], query?: Requirements | undefined): Promise<Requirements[]> {
        throw new Error("Method not implemented.");
    }

}
const scopeCssToOdrl: Map<string, string> = new Map();
scopeCssToOdrl.set('urn:example:css:modes:read','http://www.w3.org/ns/odrl/2/read');
scopeCssToOdrl.set('urn:example:css:modes:append','http://www.w3.org/ns/odrl/2/append');
scopeCssToOdrl.set('urn:example:css:modes:create','http://www.w3.org/ns/odrl/2/create');
scopeCssToOdrl.set('urn:example:css:modes:delete','http://www.w3.org/ns/odrl/2/delete');
scopeCssToOdrl.set('urn:example:css:modes:write','http://www.w3.org/ns/odrl/2/write');

const scopeOdrlToCss : Map<string, string> = new Map(Array.from(scopeCssToOdrl, entry => [entry[1], entry[0]]));

function transformActionsCssToOdrl(actions: string[]): string[] {
    // scopes come from UmaClient.ts -> see CSS package

    // in UMAPermissionReader, only the last part of the URN will be used, divided by a colon
    // again, see CSS package
    return actions.map(action => scopeCssToOdrl.get(action)!);
}

function transformActionsOdrlToCss(actions: string[]): string[] {
    const cssActions = []
    for (const action of actions) {
        if (action === 'http://www.w3.org/ns/odrl/2/use'){
            return Array.from(scopeCssToOdrl.keys());
        }
        cssActions.push(scopeOdrlToCss.get(action)!);
    }
    return cssActions;
}

type PolicyReport = {
    id: NamedNode;
    created: Literal;
    request: NamedNode;
    policy: NamedNode;
    ruleReport: RuleReport;
}
type RuleReport = {
    id: NamedNode;
    type: RuleReportType;
    activationState: ActivationState
    // TODO: others
    premiseReport: PremiseReport[]
}

type PremiseReport = {
    id: NamedNode;
    type:PremiseReportType;
    premiseReport: PremiseReport[];
    satisfactionState: SatisfactionState
}

// is it possible to just use CR.namespace + "term"?
// https://github.com/microsoft/TypeScript/issues/40793
enum RuleReportType {
    PermissionReport= 'http://example.com/report/temp/Permission',
    ProhibitionReport= 'http://example.com/report/temp/Prohibition',
    ObligationReport= 'http://example.com/report/temp/Obligation',
}
enum SatisfactionState {
    Satisfied= 'http://example.com/report/temp/Satisfied',
    Unsatisfied= 'http://example.com/report/temp/Unsatisfied',
}

enum PremiseReportType {
    ConstraintReport = 'http://example.com/report/temp/ConstraintReport',
    PartyReport = 'http://example.com/report/temp/PartyReport',
    TargetReport = 'http://example.com/report/temp/TargetReport',
    ActionReport = 'http://example.com/report/temp/ActionReport',
}

enum ActivationState {
    Active= 'http://example.com/report/temp/Active',
    Inactive= 'http://example.com/report/temp/Inactive',
}
function parseComplianceReport(identifier: Quad_Subject, store: Store):PolicyReport{
    const exists = store.getQuads(identifier,RDF.type,CR.PolicyReport, null).length ===1;
    if (!exists) { throw Error(`No Policy Report found with: ${identifier}.`); }
    const ruleReportNode = store.getQuads(identifier,CR.ruleReport, null, null)[0].object as NamedNode;
    const premises :PremiseReport[] = [];
    const premiseNodes = store.getObjects(ruleReportNode,CR.premiseReport, null) as NamedNode[];
    for (const premiseNode of premiseNodes) {
        premises.push({
            id: premiseNode,
            type: store.getObjects(premiseNode, RDF.type, null)[0].value as PremiseReportType,
            premiseReport:[], // Note: won't get nested premises this way
            satisfactionState: store.getObjects(premiseNode, CR.satisfactionState, null)[0].value as SatisfactionState
        })
    }
    const ruleReport :RuleReport = {
        id: ruleReportNode,
        type: store.getObjects(ruleReportNode, RDF.type, null)[0].value as RuleReportType,
        activationState: store.getObjects(ruleReportNode, CR.activationState, null)[0].value as ActivationState,
        premiseReport: premises
    }
    return {
        id: identifier as NamedNode,
        created: store.getObjects(identifier, DC.namespace+"created", null)[0] as Literal,
        policy: store.getObjects(identifier, CR.policy, null)[0] as NamedNode,
        request: store.getObjects(identifier, CR.policyRequest, null)[0] as NamedNode,
        ruleReport: ruleReport
    }
}

const CR = createVocabulary('http://example.com/report/temp/',
    'PolicyReport',
    'RuleReport',
    'PermissionReport',
    'ProhibitionReport',
    'DutyReport',
    'PremiseReport',
    'ConstraintReport',
    'PartyReport',
    'ActionReport',
    'TargetReport',
    'ActivationState',
    'Active',
    'Inactive',
    'AttemptState',
    'Attempted',
    'NotAttempted',
    'PerformanceState',
    'Performed',
    'Unperformed',
    'Unknown',
    'DeonticState',
    'NonSet',
    'Violated',
    'Fulfilled',
    'SatisfactionState',
    'Satisfied',
    'Unsatisfied',
    'policy',
    'policyRequest',
    'ruleReport',
    'conditionReport',
    'premiseReport',
    'rule',
    'ruleRequest',
    'activationState',
    'attemptState',
    'performanceState',
    'deonticState',
    'constraint',
    'satisfactionState',
    )
